** The prototype:
:PROPERTIES:
:CUSTOM_ID: the-prototype
:END:
- All objects in JavaScript have a prototype that its children can
  inherit.

#+begin_src js
function Player(name, marker){
    this.name = name;
    this.marker = marker;
    this.sayName = function() {
        console.log(this.name)
    };
}

const player1 = new Player('steve', 'X');
const player2 = new Player('also steve', 'O');

Player.prototype.sayHello = function () {
    console.log("Hello I'm a player");
};

player1.sayHello();
player2.sayHello();
#+end_src

- Object.prototype -> Player.prototype -> Player objects (player1,
  player2)

- Every =prototype= object inherits from =Object.prototype= by default.

- You can =.setPrototypeOf= an object for example you can do:
  =Object.setPrototypeOf(Player.prototype, Person.prototype)= and then
  when you do =Object.getProtypeOf(Player.prototype)= it will return
  =Person.prototype=. This way we can access both functions from
  =Player= and =Person= prototypes.

#+begin_src js
function Person(name){
    this.name = name;
}

Person.prototype.sayName = function() {
    console.log(`Hello, I'm ${this.name}!`);
};

function Player(name, marker){
    this.name = name;
    this.marker = marker;
}

Player.prototype.getMarker = function(){
    console.log(`My marker is '${this.marker}'`);
};

Object.getPrototypeOf(Player.prototype);

Object.setPrototypeOf(Player.prototype, Person.prototype);
Object.getPrototypeOf(Player.prototype);


const player1 = new Player('steve', 'X');
const player2 = new Player('also steve', 'O');

player1.sayName();
player2.sayName();

player1.getMarker();
player2.getMarker();
#+end_src

Note: - Make sure you do =Object.setPrototypeOf()= before creating any
objects as this will cause performance issues

** Writing doesn't use prototype
:PROPERTIES:
:CUSTOM_ID: writing-doesnt-use-prototype
:END:
- The prototype is only used for reading properties, Write/delete works
  directly with the object.
- Accessor properties are the exception, as assignment is handled by a
  setter function. So writing to such a property is actually the same as
  calling a function.
- We can use the built-in method =.hasOwnProperty(key)= to check if the
  property is inherited or not.
- this refers to the object we pass in when we call our method. This way
  we can modify the states of the inheriting objects but not the parent
  object.

** Closures:
:PROPERTIES:
:CUSTOM_ID: closures
:END:
#+begin_src js
function makeAdding (firstNumber)
{
    const first = firstNumber;
    return function resulting (secondNumber){
        const second = secondNumber;
        return first + second;
    }
}

const add5 = makeAdding(5);
console.log(add5(2)) // logs 7
#+end_src

1) the =makeAdding= function takes an argument, =firstNumber=, declares
   a constant =first= with the value of =firstNumber=, and returns
   another function.
2) when an argument is passed to the returned function, which we have
   assigned to add5, it returns the result of adding up the number
   passed earlier to the number passed now.

Functions in JavaScript form closures. A closure refers to the
combination of a function and the surrounding state in which the
function was declared. This surrounding state in which the function was
declared.

This surrounding state, also called its lexical environment, consists of
any local variables that were in scope at the time of the closure was
made.

Here, =add5= is a reference to the =resulting= function, created when
the =makeAdding= function is executed, thus it has access to lexical
environment of the =resulting= function, which contains the =first=
variable, making it available for use.

** Lexical scope?
:PROPERTIES:
:CUSTOM_ID: lexical-scope
:END:
Lexical scope refers to the context in which variables and functions are
accessible or visible. Lexical Scopes can be broadly classified into two
categories: Global Scope and Local Scope.

** Lexical Environment?
:PROPERTIES:
:CUSTOM_ID: lexical-environment
:END:
Lexical Environment, on the other hand, is a more concrete mechanism
employed by JavaScript's engine during runtime to manage and access the
variables based on the Lexical Scope. It is part of the JavaScript
execution context that consists of two significant parts: 1) The
Environment Record: This is where the specific variables, constants, and
functions defined within the Lexical Scope are actually stored. 2) A
reference to the outer environment: This refers to the Lexical
Environment of the parent scope. It allows for the chain through which
Javascript searches for variable values when a variable isn't found in
the immediate Lexical Environment.

Lexical environments are created every time a block of code or a
function is executed containing all the local variables and being linked
to an outer Lexical Environment. This effectively forms a Scope Chain
that determines how variable lookups occur during the execution of the
code.

** Factory functions :factory:
:PROPERTIES:
:CUSTOM_ID: factory-functions-factory
:END:
They work similar to how constructors do, but with one clear difference,
they levy the power of closures, instead of using the =new= keyword to
create an object. Factory functions set up and return the new object
when you call the function. They do not use the prototype, which incurs
a performance penalty. Though as a general rule this performance penalty
isn't significant unless you're creating a thousand of objects.

#+begin_src js
const User = function (name){
    this.name = name;
    this.discordName = "@" + name;
}
//this is a constructor -
//then this can be turned into a factory


function createUser(name){
    const discordName = "@" + name;
    return {name, discordName};
}
#+end_src

*** The object shorthand notation
:PROPERTIES:
:CUSTOM_ID: the-object-shorthand-notation
:END:
#+begin_src js
const name = "Bob";
const age = 28;
const color = "red";

const thatObject = { name: name, age: age, color: color };

//if we have variables with the same name as that of the property we are assigning to
// then we can write it once.
const nowFancyObject = { name, age, color };

console.log( name, age, color ); //this outputs a mess Bob 28 red

console.log({ name, age, color }); //this now logs as {name: "Bob", age: 28, color: "red"}
#+end_src

**** Destructuring:
:PROPERTIES:
:CUSTOM_ID: destructuring
:END:
When you have an object, you can extract a property of an object into a
variable of the same name, or any named variable for an array.

#+begin_src js
const obj = { a: 1, b:2 };
const { a, b } = obj;
// This creates two variables, a and b
// which are equivalent to
// const a = obj.a
// const b = obj.b

const array = [1, 2, 3, 4, 5];
const [ zerothEle, firstEle ] = array;
// this creates zerothEle and firstEle, both of which point
// to the elemtns in the 0th and 1st indices of the array
#+end_src

*** Destructuring examples:
:PROPERTIES:
:CUSTOM_ID: destructuring-examples
:END:
- Example 1:

#+begin_src js
let a, b, rest;
[ a, b ] = [10, 20];

console.log(a);
// should return 10

console.log(b);
// should return 20

[ a, b, ...rest ] = [10, 20, 30, 40, 50];

console.log(rest);
#+end_src

**** Binding and Assignment
:PROPERTIES:
:CUSTOM_ID: binding-and-assignment
:END:
#+begin_src js
const obj = { a: 1, b: {c: 2 } };
const {
    a,
    b: { c: d },
} = obj;
// Two variables are bound: 'a' and 'd'
#+end_src

#+caption: image
[[../images/binding_and_assignment_1.png]]

#+begin_src js
const obj = { a: 1, b: {c: 2 } };
const { a } = obj; // a is constant

let {
    b: { c: d },
} = obj; // d is reassignable
#+end_src

#+caption: image
[[../images/binding_and_assignment_2.png]]

- We don't need to use =var= or =let=:

#+begin_src js
const numbers = [];
const obj = { a: 1, b: 2 };

({ a: numbers[0], b: numbers[1] } = obj);
#+end_src

however we need to make sure that we use parenthesis for this statement
as we are not using =var= or =let=.

**** Default values:
:PROPERTIES:
:CUSTOM_ID: default-values
:END:
Each destructuring property can have a /default/ value. The default
value is used when the property isn't present, or has value =undefined=.
It is not used if the property has a value =null=.

#+begin_src js
const [ a = 1 ] = []; // a is 1
const { b = 2 } = { b: undefined }; // b is 2
const { c = 2 } = { c: null } // c is null
#+end_src

**** Examples:
:PROPERTIES:
:CUSTOM_ID: examples
:END:
- Array destructuring:

#+begin_src js
const foo = ["one", "two", "three"];

const [red, yellow, green] = foo;
console.log(red);//"one"
console.log(yellow);// "two"
console.log(green);// "three"
#+end_src

- Swapping variables:

#+begin_src js
let a = 1;
let b = 3;

[a, b] = [b, a];
console.log(a);// 3
console.log(b); // 1

const arr = [1, 2, 3];
[arr[2], arr[1]] = [arr[1], arr[2]];
console.log(arr); //[1, 3, 2]
#+end_src

- Parsing an array returned from a function

#+begin_src js
function f(){
    return [1, 2];
}
const [a, b] = f();
console.log(a); // 1
console.log(b); // 2
#+end_src

- Ignoring some returned values

#+begin_src js
function f(){
    return [1, 2, 3];
}
const [a, , b] = f();
console.log(a); // 1
console.log(b); // 3

const [c] = f();
console.log(c); //1
#+end_src

** Private variables and functions:
:PROPERTIES:
:CUSTOM_ID: private-variables-and-functions
:END:
#+begin_src js
function createUser(name){
    const discordName = "@" + name;

    let reputation = 0;

    const getReputation = () => reputation;
    const setReputation = () => reputation++;

    return { name, discordName, getReputation, setReputation };
}

const john = createUser("john");

john.setReputation();
john.setReputation();

console.log({
    discordName: john.discordName,
    reputation: john.getReputation(),
});
#+end_src

** Prototypal inheritance with factories
:PROPERTIES:
:CUSTOM_ID: prototypal-inheritance-with-factories
:END:
#+begin_src js
function createPlayer (name, level){
    const { getReputation, giveReputation } = createUser(name);

    const increaseLevel = () => level++;
    return { name, getReputation, giveReputation, increaseLevel };
}
#+end_src

- In case we want to extend User and want to inherit all its properties
  we can use this instead

#+begin_src js
function createPlayer(name, level){
    const user = createUser(name);

    const increaseLevel = () => level++;
    return Object.assign({}, user, {increaseLevel});
}
#+end_src

- In this example we can see that we inherit all properties so, we get
  the =discordName= property as well.

** The module pattern: IIFEs
:PROPERTIES:
:CUSTOM_ID: the-module-pattern-iifes
:END:
#+begin_src js
const calculator = (function(){
    const add = (a, b) => a + b;
    const sub = (a, b) => a - b;
    const mul = (a, b) => a * b;
    const div = (a, b) => a / b;
    return { add, sub, mul, div };
})();

calculator.add(3,5);
calculator.sub(6,2);
calculator.mul(14, 5534);
#+end_src
* Shallow Copy vs Deep Copy
:PROPERTIES:
:CUSTOM_ID: shallow_copy_vs_deep_copy
:END:
#+begin_src js
array = [
    [0 , 0 , 0],
    [0 , 0 , 0],
    [0 , 0 , 0],
];

let shallow = array.map(row => row);

shallow[0][0] = 5;

console.log(shallow);
console.log(array);
#+end_src
- When you modify the shallow array changes will also be made to the original array, see output below:
#+begin_src
  [ [ 5, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ]
  [ [ 5, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ]
#+end_src

- However, when you do a deep copy this doesn't happen:
#+begin_src js
array = [
    [0 , 0 , 0],
    [0 , 0 , 0],
    [0 , 0 , 0],
];

let deep = array.map((rowArr, r) => [...rowArr]);

deep[0][0] = 5;

console.log(deep);
console.log(array);
#+end_src

- The resulting output is:
#+BEGIN_SRC
[ [ 5, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ]
[ [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ]
#+END_SRC

* Classes:
- "Class" doesn't exist in javascript.
** Javascript object creation differs from say Java
#+CAPTION: javascript object creation vs java
#+NAME: fig:java_vs_javascript
[[../images/java_vs_javascript.png]]
- In Java we need a blueprint for the object to exist called Class.
- In JS, objects don't need classes to exist, they come with a
  plug and socket mechanism called "prototype" that can be used to
  wire up different objects.
* Getters and setters:
#+BEGIN_SRC js
let obj = {
    get propName(){
	//getter, the code executed on getting obj.propName
    },
    set propName(value){
	//setter, the code exectuted on setting obj.propName = value
    }
};
#+END_SRC

#+BEGIN_SRC js
   let user = {
       name: "John",
       surname: "Smith",

       get fullName() {
   	return `${this.name} ${this.surname}`;
       }
   };

  console.log(user.fullName);
#+END_SRC

*** RESULTS:
: John Smith
: undefined


#+BEGIN_SRC js
  let user = {
      get fullName() {
  	return `...`;
      }
  };
  user.fullName = "Test"; //Error (property has only a getter)
#+END_SRC

*** RESULTS:
: undefined


#+BEGIN_SRC js
  let user = {
      name: "John",
      surname: "Smith",

      get fullName() {
  	return `${this.name} ${this.surname}`;
      },
      set fullName(value) {
  	[this.name, this.surname] = value.split(" ");
      }
  };
  user.fullName = "Alice Cooper"; //setting fullanem

  console.log(user.name);
  console.log(user.surname);
#+END_SRC

*** RESULTS:
: Alice
: Cooper
: undefined


* Accessor Descriptors
#+BEGIN_SRC js
  let user = {
      name: "John",
      surname: "Smith"
  };
  Object.defineProperty(user, 'fullName', {
      get() {
  	return `${this.name} ${this.surname}`;
      },
      set(value) {
  	[this.name, this.surname] = value.split(" ");
      }
  });
  console.log(user.fullName); //john smith
  for(let key in user) console.log(key); //name, surname
#+END_SRC

*** RESULTS:
: John Smith
: name
: surname
: undefined


- for accessor properties, there is no =value= or =writable=, but instead
  there ar =get= and =set= functions

* Smarter getters/setters
#+BEGIN_SRC js
  let user = {
      get name() {
  	return this._name;
      },
      set name(value) {
  	if(value.length < 4) {
  	    console.log("Name is too short, need at least 4 chars");
  	    return;
  	}
  	this._name = value;
      }
  };
  user.name = "Pete";
  console.log(user.name); //pete

  user.name = ""; //name too short
#+END_SRC

*** RESULTS:
: Pete
: Name is too short, need at least 4 chars
: undefined


** Using for compatability
#+BEGIN_SRC js
  function User(name, age) {
      this.name = name;
      this.age = age;
  }
  let john = new User("John", 25);

  console.log( john.age );
#+END_SRC

*** RESULTS:
: 25
: undefined


- However, sooner or later things may change, instead of age we might want
  store =birthday=, because it's more precise and convenient.

  #+BEGIN_SRC js
    function User(name, birthday) {
        this.name = name;
        this.birthday = birthday;
    }
    let john = new User("John", new Date(1992, 6, 1));
    console.log( john );
  #+END_SRC

*** RESULTS:
  : User { name: 'John', birthday: 1992-06-30T23:00:00.000Z }
  : undefined
  
  

- Now the question is what do we do with the old code that uses #age property?
- We can keep it by adding a getter for #age
  #+BEGIN_SRC js
    function User(name, birthday) {
        this.name = name;
        this.birthday = birthday;

        Object.defineProperty(this, "age", {
    	get() {
    	    let todayYear = new Date().getFullYear();
    	    return todayYear - this.birthday.getFullYear();
    	}
        });
    }
    let john = new User("John", new Date(1992, 6, 1));

    console.log( john.birthday );
    console.log( john.age );
  #+END_SRC

*** RESULTS:
  : 1992-06-30T23:00:00.000Z
  : 32
  : undefined

  
* Class Syntax
#+BEGIN_SRC js
  class User{
      constructor(name){
  	this.name = name;
      }
      sayHi(){
  	console.log(this.name);
      }
  }

  //Usage
  let user = new User("John");
  user.sayHi();
#+END_SRC

*** RESULTS:
: John
: undefined

** What is a class?
#+BEGIN_SRC js
    class User {
        constructor(name) { this.name = name; }
        sayHi() { console.log(this.name); }
    }
  //proof: User is a function
  console.log(typeof User); //function
#+END_SRC

*** RESULTS:
: function
: undefined

- What is basically does it:
  1) Creates a function named =User=, that becomes the result of the class
     declaration. The function code is taken from the =constructor= method.
  2) Stores class methods, such as =sayHi=, in =User.prototype=.
    
#+CAPTION: What classes are in javascript under the hood
[[../images/class.png]]

#+BEGIN_SRC js
  class User {
      constructor(name) { this.name = name; }
      sayHi() { console.log(this.name); }
  }
  //class is a function
  console.log(typeof User);//function

  console.log(User === User.prototype.constructor);

  console.log(User.prototype.sayHi);

  console.log(Object.getOwnPropertyNames(User.prototype));
#+END_SRC

*** RESULTS:
: function
: true
: [Function: sayHi]
: [ 'constructor', 'sayHi' ]
: undefined

** Class Expression
#+BEGIN_SRC js
  let User = class MyClass{
      sayHi() {
  	console.log(MyClass);
      }
  };
  new User().sayHi(); //works, shows MyClass definition
  console.log(MyClass); // does not work
#+END_SRC

*** RESULTS:
: [class MyClass]

- We can also make classes on demand like this:
#+BEGIN_SRC js
  function makeClass(phrase){
      return class{
  	sayHi(){
  	    console.log(phrase);
  	}
      };
  }
  //Create a new class
  let User = makeClass("Hello");
  new User().sayHi();
#+END_SRC

*** RESULTS:
: Hello
: undefined

** Getters/setters
#+BEGIN_SRC js
  class User {
      constructor(name) {
  	this.name = name;
      }
      get name() {
  	return this._name;
      }
      set name(value) {
  	if (value.length < 4) {
  	    console.log("name is too short");
  	    return;
  	}
  	this._name = value;
      }
  }
  let user = new User("John");
  console.log(user.name); // John

  user = new User(" ");
#+END_SRC

*** RESULTS:
: John
: name is too short
: undefined

** Class fields:
#+BEGIN_SRC js
  class User {
      name = "John";

      sayHi() {
  	console.log(`Hello, ${this.name}! `);
      }
  }
  new User().sayHi(); 
#+END_SRC

*** RESULTS:
: Hello, John! 
: undefined

- Note, class fields only apply to teh individual objects, not =User.prototype=

#+BEGIN_SRC js
  class User{
      name = "John";
  }
  let user = new User();
  console.log(user.name);
  console.log(User.prototype.name);
#+END_SRC

#+RESULTS:
: John
: undefined
: undefined

** Making bound methods with class fields
#+BEGIN_SRC js
  class Button {
      constructor(value){
  	this.value = value;
      }
      click() {
  	console.log(this.value);
      }
  }
  let button = new Button("hello");
  setTimeout(button.click, 1000); //undefined
#+END_SRC

*** RESULTS:
: undefinedundefined

- The problem is called losing =this=
- This can be fixed by:
  1) Pass a wrapper function such as =setTimeout(()=> button.click(), 1000).
  2) Bind the method to the object e.g. in the constructor.

We can use class fields instead as well:

#+BEGIN_SRC js
  class Button{
      constructor(value){
  	this.value = value;
      }
      click = () => {
  	console.log(this.value);
      }
  }
  let button = new Button("hello");

  setTimeout(button.click, 1000); 
#+END_SRC

*** RESULTS:
: undefinedhello

** Extends:
The =extends= keyword is used to create a class that is a child of another class.

#+BEGIN_SRC js
  class DateFormatter extends Date {
      getFormattedDate() {
  	const months = [
  	    'Jan',
  	    'Feb',
  	    'Mar',
  	    'Apr',
  	    'May',
  	    'Jun',
  	    'Jul',
  	    'Aug',
  	    'Sep',
  	    'Oct',
  	    'Nov',
  	    'Dec',
  	];
  	return `${this.getDate()}-${months[this.getMonth()]}-${this.getFullYear()}`;
      }
  }
  console.log(new DateFormatter('August 19, 1975 23:15:30').getFormattedDate());
#+END_SRC

*** RESULTS:
: 19-Aug-1975
: undefined

#+BEGIN_SRC js
  function OldStyleClass(){
      this.someProperty = 1;
  }
  OldStyleClass.prototype.someMethod = function () {};

  class ChildClass extends OldstyleClass {}

  class ModernClass {
      someProperty = 1;
      someMethod(){}
  }

  class AnotherChildClass extends ModernClass {}
#+END_SRC

#+BEGIN_SRC js
  class ParentClass {}
  class ChildClass extends ParentClass {}

  console.log(Object.getPrototypeOf(ChildClass) === ParentClass);
  console.log(Object.getPrototypeOf(ChildClass.prototype) === ParentClass.prototype);
#+END_SRC

*** RESULTS:
: true
: true
: undefined

#+BEGIN_SRC js
  class SomeClass extends class {
      constructor() {
  	console.log("Base class");
      }
  } {
      constructor() {
  	super();
  	console.log("Derived class");
      }
  }
  console.log(new SomeClass());
#+END_SRC

*** RESULTS:
: Base class
: Derived class
: SomeClass {}
: undefined

- The base class may return anything from its constructor, the derived
  class must return an objet or =undefined=, or a typeerror will be thrown

#+BEGIN_SRC js
  class ParentClass {
      constructor() {
  	return 1;
      }
  }
  console.log(new ParentClass()); // ParentClass {}

  class ChildClass extends ParentClass {
      constructor(){
  	super();
  	return 1;
      }
  }
  console.log(new ChildClass()); // TypeError
#+END_SRC

*** RESULTS:
: ParentClass {}

#+BEGIN_SRC js
  class ParentClass {
      constructor() {
  	return 1;
      }
  }
  console.log(new ParentClass()); // ParentClass {}

  class ChildClass extends ParentClass {
      constructor(){
  	super();
  	return undefined;
      }
  }
  console.log(new ChildClass()); // ChildClass {}
#+END_SRC

*** RESULTS:
: ParentClass {}
: ChildClass {}
: undefined

** Extending null
- useful when you want to create objects that do not inherit from =Object.prototype=.
#+BEGIN_SRC js
  class NullClass extends null {
      constructor() {
  	return Object.create(new.target.prototype);
      }
  }
  const proto = Object.getPrototypeOf;
  console.log(proto(proto(new NullClass()))); //null
#+END_SRC

*** RESULTS:
: null
: undefined

** Extending plain objects
#+BEGIN_SRC js
  const Animal = {
      speak() {
  	console.log(`${this.name} makes a noise.`);
      },
  };
  class Dog {
      constructor(name) {
  	this.name = name;
      }
  }
  Object.setPrototypeOf(Dog.prototype, Animal);

  const d = new Dog("Mitzie");
  d.speak();
#+END_SRC

*** RESULTS:
: Mitzie makes a noise.
: undefined

** Species
If for example you want to return an =Array= object from your derived array class
=MyArray=. You can use the species pattern.

#+BEGIN_SRC js
  class MyArray extends Array {
      static get [Symbol.species]() {
  	return Array;
      }
  }
  const a = new MyArray(1, 2, 3);
  const mapped = a.map((x) => x * x);

  console.log(mapped instanceof MyArray); //false
  console.log(mapped instanceof Array); // true
#+END_SRC

*** RESULTS:
: false
: true
: undefined

** Mix-ins
Abstract subclasses or min-ins are templates for classes.

#+BEGIN_SRC js
   const calculatorMixin = (Base) =>
         class extends Base {
   	  calc() {}
         };
   const randomizerMixin = (Base) =>
         class extends Base {
   	  randomize() {}
         };

  // A class that uses mixins can be written like:
  class Foo {}
  class Bar extends calculatorMixin(randomizerMixin(Foo)) {}
#+END_SRC


